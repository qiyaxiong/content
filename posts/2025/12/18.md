---
title: LangGraph Checkpoint 机制详解
published: 2025-12-18
description: 深入理解LangGraph的checkpoint机制，包括start、continue、fork三种操作的使用方式和数据库存储结构
tags: [LangGraph, Checkpoint, 状态管理]
category: AI工程
draft: false
---
# LangGraph Checkpoint 机制详解

## 概述

LangGraph 的 checkpoint 机制是用于持久化和管理图执行状态的核心功能。它允许在长时间运行的代理任务中保存和恢复执行状态，支持从任意检查点继续执行或创建新的执行分支。

## 核心操作

### 1. Start（启动）

**功能**：启动一个新的图执行流程

**特点**：

- 创建新的 `thread_id`（线程ID）
- 生成初始 checkpoint（checkpoint0）
- checkpoint0 是执行流程的起点，包含初始状态

**使用场景**：

- 首次启动图执行
- 创建全新的对话或任务流程

### 2. Continue（继续）

**功能**：从当前检查点继续执行

**参数**：

- `current_checkpoint_id`：当前最新的 checkpoint ID（由之前的执行生成）

**特点**：

- 使用已存在的 checkpoint ID
- 从该 checkpoint 的状态继续执行
- 每次执行后生成新的 checkpoint ID

**使用场景**：

- 在已有执行流程中继续推进
- 恢复中断的执行
- 顺序执行多个步骤

**示例流程**：

```
start() → checkpoint0 (id: abc123)
continue(abc123) → checkpoint1 (id: def456)
continue(def456) → checkpoint2 (id: ghi789)
```

### 3. Fork（分支）

**功能**：从指定的检查点创建新的执行分支

**参数**：

- `checkpoint_id`：指定的 checkpoint ID（通常是 start 前保存的 checkpoint0）

**特点**：

- 从历史 checkpoint 创建新分支
- 不修改原始执行流程
- 可以基于任意历史状态创建多个分支

**使用场景**：

- 探索不同的执行路径
- 回退到历史状态重新执行
- 并行测试不同的策略
- 从 checkpoint0 创建新的执行分支

**示例流程**：

```
start() → checkpoint0 (id: abc123)
continue(abc123) → checkpoint1 (id: def456)
fork(abc123) → 新分支从 checkpoint0 开始
```

## 数据库存储结构

LangGraph 使用四个核心表来存储 checkpoint 数据：

### 1. checkpoint_migrations（迁移表）

**作用**：跟踪数据库 schema 版本

**字段**：

- 记录已应用的数据库迁移版本
- 确保 schema 升级的安全性

### 2. checkpoints（检查点表）

**作用**：存储核心 checkpoint 信息和元数据

**关键字段**：

- `thread_id`：线程ID，标识执行流程
- `checkpoint_ns`：checkpoint 命名空间
- `checkpoint_id`：checkpoint 唯一标识（UUIDv6）
- `parent_checkpoint_id`：父 checkpoint ID，形成执行链
- `type`：checkpoint 类型
- `checkpoint`：checkpoint 数据（BLOB）
- `metadata`：元数据（BLOB）
- 元数据索引字段（用于高效过滤）

**checkpoint0 存储**：

- ✅ **checkpoint0 会被存储在 checkpoints 表中**
- checkpoint0 是执行流程的起点
- `parent_checkpoint_id` 为 NULL 或特殊值
- 包含初始状态和配置信息

### 3. checkpoint_blobs（二进制对象表）

**作用**：存储序列化的 channel 值（大型二进制对象）

**特点**：

- 存储大型数据对象
- 与 checkpoints 表关联
- 优化存储和检索性能

### 4. checkpoint_writes（写入日志表）

**作用**：存储与 checkpoint 相关的待写入数据

**特点**：

- 记录中间写入操作
- 在工具或其他步骤执行时记录
- 在创建新 checkpoint 时合并

**关键字段**：

- `thread_id`：线程ID
- `checkpoint_ns`：checkpoint 命名空间
- `checkpoint_id`：关联的 checkpoint ID
- `task_id`：任务ID
- `task_path`：任务路径
- `channel`：channel 名称
- `value`：值（BLOB）

## 执行流程示例

### 标准流程

```
1. start()
   ├─ 创建 thread_id: "thread_001"
   ├─ 生成 checkpoint0 (id: "checkpoint_0")
   └─ 存储到 checkpoints 表

2. continue(checkpoint_0)
   ├─ 从 checkpoint_0 恢复状态
   ├─ 执行下一步
   ├─ 生成 checkpoint1 (id: "checkpoint_1")
   └─ parent_checkpoint_id = "checkpoint_0"

3. continue(checkpoint_1)
   ├─ 从 checkpoint_1 恢复状态
   ├─ 执行下一步
   ├─ 生成 checkpoint2 (id: "checkpoint_2")
   └─ parent_checkpoint_id = "checkpoint_1"

4. fork(checkpoint_0)
   ├─ 从 checkpoint_0 创建新分支
   ├─ 使用新的 thread_id: "thread_002"
   ├─ 生成新的 checkpoint (id: "checkpoint_3")
   └─ parent_checkpoint_id = "checkpoint_0"
```

### 分支探索流程

```
主流程：
start() → checkpoint0
continue(checkpoint0) → checkpoint1
continue(checkpoint1) → checkpoint2

分支1（从 checkpoint0 开始）：
fork(checkpoint0) → checkpoint3
continue(checkpoint3) → checkpoint4

分支2（从 checkpoint1 开始）：
fork(checkpoint1) → checkpoint5
continue(checkpoint5) → checkpoint6
```

## 关键要点

### Checkpoint0 的存储

**问题**：LangGraph 那四个表存了 checkpoint0 了吗？

**答案**：✅ **是的，checkpoint0 会被存储**

1. **checkpoints 表**：

   - checkpoint0 作为初始 checkpoint 存储在 checkpoints 表中
   - `parent_checkpoint_id` 为 NULL（因为是起点）
   - 包含完整的初始状态信息
2. **checkpoint_blobs 表**：

   - 如果初始状态包含大型对象，会存储在 checkpoint_blobs 表中
3. **checkpoint_writes 表**：

   - 初始写入操作会记录在 checkpoint_writes 表中
4. **checkpoint_migrations 表**：

   - 记录 schema 版本，不直接存储 checkpoint0，但确保表结构正确

### 使用建议

1. **Start 操作**：

   - 只在需要创建新流程时使用
   - 会自动生成 checkpoint0
2. **Continue 操作**：

   - 使用最近生成的 checkpoint_id
   - 适合顺序执行和恢复中断
3. **Fork 操作**：

   - 使用历史 checkpoint_id（如 checkpoint0）
   - 适合探索不同执行路径
   - 可以基于任意历史状态创建分支

### 最佳实践

1. **保存 checkpoint0**：

   - 在 start() 后保存返回的 checkpoint_id
   - 用于后续的 fork 操作
2. **跟踪执行链**：

   - 通过 `parent_checkpoint_id` 可以追踪完整的执行历史
   - 支持回退和分支操作
3. **状态管理**：

   - 每个 checkpoint 包含完整的状态快照
   - 可以从任意 checkpoint 恢复执行
4. **并发控制**：

   - 使用 `thread_id` 隔离不同的执行流程
   - fork 操作会创建新的 thread_id

## 总结

LangGraph 的 checkpoint 机制提供了强大的状态管理能力：

- **Start**：创建新流程，生成 checkpoint0
- **Continue**：从当前 checkpoint 继续，使用 `current_checkpoint_id`
- **Fork**：从历史 checkpoint 分支，使用指定的 `checkpoint_id`（如 checkpoint0）

四个数据库表协同工作，确保 checkpoint 数据的完整存储和高效检索：

- ✅ checkpoint0 会被存储在 checkpoints 表中
- ✅ 大型对象存储在 checkpoint_blobs 表中
- ✅ 写入操作记录在 checkpoint_writes 表中
- ✅ 迁移信息记录在 checkpoint_migrations 表中

这种设计使得 LangGraph 能够支持长期运行的代理任务，在多个上下文窗口之间保持状态一致性，实现可靠的增量执行和分支探索。
